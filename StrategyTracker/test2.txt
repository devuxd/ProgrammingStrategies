STRATEGY localizeFailure(failure)
	# You can capture this in whatever form is easiest to write down.
	# The most common format is a series of reproduction steps.
	# Note that if you do not have reliable reproduction steps, this strategy will be difficult to use.
	SET 'inputs' to the sequence of inputs that reproduces the failure reliably
	IF 'failure' is output that should not have occurred but did
		RETURN localizeWrongOutput(failure)
	IF the failure is output that should have occurred but did not
		RETURN localizeMissingOutput(failure)
	RETURN nothing

STRATEGY localizeWrongOutput(failure)
	# For example, if it was console output, this might be a print statement.
	# If it is user interface output, this might be whatever component was responsible for rendering the output.
	# If you do not know how to find these line, one strategy is to find a unique feature in the output
	# such as a string constant and do a global search in the code for that string.
	SET 'candidateLines' to all of the lines of code that could have directly produced the incorrect output
	SET 'cause' TO nothing
	FOR EACH 'line' IN 'candidateLines'
		# You can use a breakpoint or a time-travel debugger to do this.
		Execute the program to 'line' using the 'failure' inputs
		IF the program executes 'L'
			SET 'values' TO all values in memory and all values of local variables in the call stack that resulted in 'line' being reached
			FOR EACH 'value' IN 'values'
				IF 'value' is not correct in this context
					RETURN localizeWrongValue('failure' 'value')
	RETURN nothing

STRATEGY localizeWrongValue(failure value)
	# This involves tracking all of the possible sources of the wrong value.
	SET 'lines' to all of the lines of the the program that can produce the 'value'
	FOR EACH 'line' in 'lines'
		# Use breakpoints or a time-travel debugger. If your debugger supports reverse execution, this is a matter of stepping backwards. If not, you may have to reproduce failure more than once to find the last execution.
		Execute the program this line
		Reflect on the intended behavior of the line and whether it achieves this behavior
		# You've found the bug!
		IF 'line' is incorrect
			RETURN 'line'
		SET 'values' TO all of the values used by 'line'
		FOR EACH 'value' IN 'values'
			IF 'value' is incorrect
				DO localizeWrongValue('failure' 'value')
	RETURN nothing

STRATEGY localizeMissingOutput(failure)
	SET 'line' TO the line of code that would have produced the output you expected
	DO diagnoseUnexecutedLine('failure' 'line')

STRATEGY diagnoseUnexecutedLine(failure line)
	# These may be an if-statements, switch-statements, or other conditional statements that would have prevented the line from executing.
	SET 'lines' TO all conditional statements conditions that would have caused line to execute
	FOR EACH 'line' IN 'lines'
		Turn on a breakpoint on 'line'
		Reproduce the failure to see if 'line' executed
		IF 'line' executed but did not execute correctly
		 	SET 'wrongValue' to the value that caused it to execute incorrectly
			RETURN localizeWrongValue('failure' 'wrongValue')
	RETURN nothing
